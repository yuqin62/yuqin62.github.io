<!DOCTYPE html>
<html>
<head>
    <!--<title>Project 2</title>-->
    <style>
        body {
            padding: 30px;
            width: 1000px;
            margin: auto;
            text-align: left;
            font-weight: 300;
            font-family: Arial, sans-serif;
        }
        h1, h2, h3 {
          font-family: 'Source Sans Pro', sans-serif;
        }
        h3 {
            font-size: 18px;
            font-weight: bold;
        }
        p {
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 15px;
        }
        .center {
            text-align: center;
        }
        .image-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .image-small {
            margin: 20px;
            width: 150px;
            height: auto;
        }
        .image-medium {
            margin: 5px;
            width: 240px;
            height: auto;
        }
        .image-large {
            margin: 10px;
            width: 300px;
            height: auto;
        }
        figcaption {
            font-family: 'Source Sans Pro', sans-serif;
            font-size: 12px;
            font-weight: normal;
            text-align: center;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1 align="middle">Project 2: Fun with Filters and Frequencies!</h1>
    <h1 align="middle">Filters/ Frequencies/ Sharpening/ Hybrid / Stacks/ Blending </h1>
    <h2 align="middle">Yuqin Jiao</h2>
    <br>
    <br>
    <h2 align="middle">Part 1: Fun with Filters</h2>
    <h3 align="middle">Part 1.1: Finite Difference Operator: description of gradient magnitude computation</h3>
    <p>
        (15 points) Include a brief description of gradient magnitude computation.
        (15 points) Answer the questions asked in part 1.2
        For computing gradient magnitude, I first applied Dx([[1, -1]]) and Dy([[1], [-1]]) to convolve with one image channel, 
        then I got partical derivative x and partical derivative y. Then I used np.sqrt(partial_derivative_x**2 + partial_derivative_y**2) 
        to compute gradient_magnitude. I chose threshold = 0.2 when binarizing the gradient magnitude image, after that, I got the first 
        edge image(fig 1_1_1).
        
    </p>
    <h3 align="middle">Part 1.2: Derivative of Gaussian (DoG) Filter: convolution is commutative</h3>
    <p>
        After creating a blurred version of the original image by convolving with a gaussian, I convolved (Image * G) 
        with Dx and Dy separately, after getting new partial derivative x and y, I chose threshold = 0.04 
        to get the edge image(fig 1_2_1), the difference between the new edge image and fig 1_1_1 in Part1.1 is: the new 
        edge image has less noise, and the edge is more clear and bloder.
        To do the same thing with a single convolution, I first convolved G with Dx and Dy, then convolve the result with original 
        image, after choosing the same threshold = 0.04, I got an edge image(fig 1_2_2), which is the same result as fig 1_2_1. So the 
        same result got has been verified. This process shows that convolution is commutative.
    </p>

    <div class="image-row">
        <figure>
            <img class="image-medium" src="media/figure1_1_1.jpg" alt="Description of figure1_1_1">
            <figcaption>[figure1_1_1] Edge Image from Part 1.1</figcaption>
        </figure>
        <figure>
            <img class="image-medium" src="media/figure1_2_1.jpg" alt="Description of figure1_2_1">
            <figcaption>[figure1_2_1] Edge Image from Part 1.2 using (Im * G) * [Dx and Dy]</figcaption>
        </figure>
        <figure>
            <img class="image-medium" src="media/figure1_2_2.jpg" alt="Description of figure1_2_2">
            <figcaption>[figure1_2_2] Edge Image from Part 1.2 using (G * [Dx and Dy]) * Im</figcaption>
        </figure>
    </div>
    <br>
    <h2 align="middle">Part 2: Fun with Frequencies</h2>
    <h3 align="middle">Part 2.1: Image Sharpening</h3>
    <p>
        for the Unsharp Masking: Show the progression of the original image to the sharpened image for 
        the given image and an image of your choice.
        According to the forlula: f +α( f − f ∗ g) = (1+α) f −α f ∗ g = f ∗((1+α)e −αg). After getting 
        the blurred image using f*g, I subtracted it from the original image f. And I applied alpha = 1 to 
        each 3 channels, after that, I got "f +α( f − f ∗ g)", then I combined this into the single convolutio operation, 
        called unsharp mask filter, which is "(1+α)e −αg". Then I applied this unsharp mask filter to the original image. 
        I first used image taj to get the sharpend result [figure2_1_1], then I downloaded an image("https://www.pinterest.com/pin/155303888060898481/"), 
        [figure2_1_2], then I blurred it using gaussian kernel to get blurred image[figure2_1_2], I applied the filter to original image to sharpen it, then I got 
        the sharpen image[figure2_1_4]. I found that when I selected alpha = 1, I got the sharpened image more sharpening than the original image.
    </p>
    <div class="image-row">
        <figure>
            <img class="image-medium" src="media/figure2_1_1.jpg" alt="Description of figure2_1_1">
            <figcaption>[figure2_1_1] sharpened image of taj</figcaption>
        </figure>
        <figure>
            <img class="image-medium" src="media/figure2_1_2.jpg" alt="Description of figure2_1_2">
            <figcaption>[figure2_1_2] original image</figcaption>
        </figure>
        <figure>
            <img class="image-medium" src="media/figure2_1_3.jpg" alt="Description of figure2_1_3">
            <figcaption>[figure2_1_3] blurred image</figcaption>
        </figure>
        <figure>
            <img class="image-medium" src="media/figure2_1_4.jpg" alt="Description of figure2_1_4">
            <figcaption>[figure2_1_4] sharpened image, clearer than the origin version</figcaption>
        </figure>
    </div>

</body>
</html>
